\section{Discussion}
\label{discuss}

\subsubsection{Language design}
High-level languages for smart contracts are designed and improved to promote safe smart contracts.
This is achieved by making state changes explicit by using an FSM/automata approach. 
They typically restrict the instruction set by only allowing finite loops and recursion.
Moreover, the code should be as explicit as possible by preventing function overloading, creating explicit types for assets and units, and promoting pure functions.
Intermediary languages are developed with formal verification and optimisations in mind.
This is an attempt to bring best practices from software engineering and language theory to distributed ledgers.
Low-level languages are built to allow formal verification and at the same time give a run-time optimised execution on a distributed ledger.

\subsubsection{Verification}
Verification efforts include categorising and defining security properties for smart contracts, developing model-based tools to verify that contracts are not vulnerable to known bugs, and formal semantics with the intention to prove compliance of a contract implementation to an abstract specification.

%\subsection{Related work}
%\citeauthor{Seijas2017} survey smart contracts for distributed ledger with a focus on Bitcoin, Ethereum, and Nxt \cite{Seijas2017}.
%%They provide an overview of the interactions between smart contracts and the underlying ledger.
%%Further, they sketch selected approaches to create smart contracts and allow for more security.
%In an empirical analysis, the use cases of smart contracts in Bitcoin and Ethereum are discussed\cite{Bartoletti2017}.
%%The authors introduce a taxonomy of smart contracts according to usage categories and design patterns in Ethereum smart contracts.
%The call graph by Ethereum contracts is evaluated in \cite{Frowis2017}.
%%An analysis of security vulnerabilities of smart contracts with a focus on the EVM is presented in \cite{Luu2016} and \cite{Atzei2017}.
%%\citeauthor{Grishchenko2018} extend this work by introducing a formal semantic definition of safety properties of smart contracts.
%
%\citeauthor{Sergey2018} present a brief overview and comparison of 13 smart contracts languages \cite{Sergey2018}. \citeauthor{Tsankov2017} include an overview and comparison to related work on smart contract verification including an evaluation of Securify, Oyente, and Maian \cite{Tsankov2017}.
%
%Apart from language design and verification, other methods are proposed to increase the security of smart contracts. Hydra is a bug-bounty and security protocol for smart contracts \cite{Breidenbach2018}. 
%%The idea is to replicate the contract logic in different implementations that need to reach consensus over state-changing executions and lock contracts if they disagree.
%NECTAR is an extension to Bitcoin's UTXO model and script set \cite{Covaci2018}. 
%%Smart contracts in this setting include a proof about its execution that can be checked to verify correctness.
%Further, game theory and Markov Decision Process (MDP) can be used to model users interacting with a smart contract \cite{Bigi2015}. 
%By applying both methods, the authors validate a protocol build on a smart contract. In that case, external factors like the users are considered explicitly as players in a game.

\subsubsection{Formal semantics and verified compilers}
A main focus is currently on developing IR with formal semantics and creating formal semantics for existing low-level languages. We argue that in the future, more projects need to adopt formal semantics on all language levels to promote verification efforts and prevent ambiguities in compiler implementations. Further, this allows to create verified compilers making it easier to argue about contracts in a high-level language \cite{Hirai2017}. 
Next, formal semantics for the EVM combine the VM and the ledger. Future work is to separate the semantics for the ledger and the execution environment. 

\subsubsection{Complete security definitions}
An initial proposal of formal security definitions is made in \cite{Grishchenko2018}. Those definitions are taken from the perspective of Solidity and the EVM. Hence, more general security definitions for various execution environments are required. Also, it could be interesting to separate the execution environment from the ledger. Moreover, proposed standards like the ERC20 can be formally defined as part of the proposal process. This would allow to verify implementations against a formal specification. Possibly, automated formal verification methods can be built on this.

%\subsubsection{Automated verification}

%\subsection{Future work}
%Formal semantics

%Verified compilers

%Automated verification