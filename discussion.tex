\section{Discussion}
\label{discuss}

High-level languages for smart contracts are designed and improved to promote safe smart contracts.
This is achieved by making state changes explicit by using an FSM/automata approach. 
They typically restrict the instruction set by only allowing finite loops and recursion.
Moreover, the code should be as explicit as possible by preventing function overloading, creating explicit types for assets and units, and promoting pure functions.
Intermediary languages are developed with formal verification and optimisations in mind.
This is an attempt to bring best practices from software engineering and language theory to distributed ledgers.
Low-level languages are built to allow formal verification and at the same time give a run-time optimised execution on a distributed ledger.

Verification efforts include categorising and defining security properties for smart contracts, developing model-based tools to verify that contracts are not vulnerable to known bugs, and formal semantics with the intention to prove compliance of a contract implementation to an abstract specification.

\subsection{Related work}
\citeauthor{Seijas2017} survey smart contracts for distributed ledger with a focus on Bitcoin, Ethereum, and Nxt \cite{Seijas2017}.
They provide an overview of the interactions between smart contracts and the underlying ledger.
Further, they sketch selected approaches to create smart contracts and allow for more security.
In an empirical analysis, the use cases of smart contracts in Bitcoin and Ethereum are discussed\cite{Bartoletti2017}.
The authors introduce a taxonomy of smart contracts according to usage categories and design patterns in Ethereum smart contracts.

The call graph by Ethereum contracts is evaluated in \cite{Frowis2017}.
An analysis of security vulnerabilities of smart contracts with a focus on the EVM is presented in \cite{Luu2016} and \cite{Atzei2017}.
\citeauthor{Grishchenko2018} extend this work by introducing a formal semantic definition of safety properties of smart contracts.

\citeauthor{Sergey2018} present a brief overview and comparison of 13 smart contracts languages \cite{Sergey2018}. \citeauthor{Tsankov2017} include an overview and comparison to related work on smart contract verification including an evaluation of Securify, Oyente, and Maian \cite{Tsankov2017}.

Apart from language design and verification, other methods are proposed to increase the security of smart contracts. Hydra is a bug-bounty and security protocol for smart contracts \cite{Breidenbach2018}. The idea is to replicate the contract logic in different implementations that need to reach consensus over state-changing executions and lock contracts if they disagree.
NECTAR is an extension to Bitcoin's UTXO model and script set \cite{Covaci2018}. Smart contracts in this setting include a proof about its execution that can be checked to verify correctness.
Further, game theory and Markov Decision Process (MDP) can be used to model users interacting with a smart contract \cite{Bigi2015}. By applying both methods, the authors validate a protocol build on a smart contract. In that case, external factors like the users are considered explicitly as players in a game.

%\subsection{Future work}
%Formal semantics

%Verified compilers

%Automated verification